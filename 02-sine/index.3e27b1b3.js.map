{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;ACAA,4BAAe;;;;ACAf,4BAAe;;;AFKf,MAAM,8BAAQ,IAAI;AAClB,MAAM,+BAAS,IAAI;AAEnB,IAAI,iCAAW,SAAS,cAAc,CAAC;AACvC,IAAI,6BAAO,+BAAS,qBAAqB;AACzC,+BAAS,MAAM;AAEf,MAAM,iCAAW,IAAI,qBAAoB,CAAC;AAC1C,+BAAS,aAAa,CAAC,OAAO,gBAAgB;AAC9C,+BAAS,OAAO,CAAC,2BAAK,KAAK,EAAE,2BAAK,MAAM;AACxC,SAAS,IAAI,CAAC,WAAW,CAAC,+BAAS,UAAU;AAE7C,IAAI,+BAAS,IAAI,0BAChB,2BAAK,KAAK,GAAG,IACb,2BAAK,KAAK,GAAG,GACb,2BAAK,MAAM,GAAG,GACd,2BAAK,MAAM,GAAG;AAEf,6BAAO,QAAQ,CAAC,GAAG,CAAC,GAAG,GAAG;AAE1B,IAAI,iCAAW;IACd,QAAQ;QAAE,OAAO;IAAE;IACnB,OAAO;QAAE,OAAO,IAAI,eAAc,2BAAK,KAAK,EAAE,2BAAK,MAAM;IAAE;IAC3D,SAAS;QAAE,MAAM;QAAM,OAAO,IAAI;IAAgB;AACnD;AAEA,IAAI,8BAAQ,6BAAO,IAAI,CAAC,+BAAS,GAAG,EAAE,IAAM;IAC3C,+BAAS,OAAO,GAAG;QAAE,MAAM;QAAK,OAAO;IAAM;IAC7C,IAAI,WAAW,IAAI;IACnB,IAAI,WAAW,IAAI,sBAAqB;kBACvC;sBACA;wBACA;QACA,SAAS;YACR,IAAI,OAAO,gBAAgB,CAAC,OAAO,CAAC;QACrC;IACD;IACA,IAAI,OAAO,IAAI,YAAW,UAAU;IACpC,KAAK,KAAK,CAAC,GAAG,CAAC,2BAAK,KAAK,EAAE,2BAAK,MAAM,EAAE;IACxC,4BAAM,GAAG,CAAC;AACX;AAEA,SAAS,WAAW,GAAG,SAAU,CAAC,EAAE;IACnC,IAAI,EAAE,MAAM,IAAI,+BAAS,UAAU,EAAE;QACpC,+BAAS,OAAO,CAAC,KAAK,CAAC,CAAC,GACvB,AAAC,CAAA,EAAE,OAAO,GAAG,+BAAS,UAAU,CAAC,UAAU,AAAD,IAAK,2BAAK,KAAK;QAC1D,+BAAS,OAAO,CAAC,KAAK,CAAC,CAAC,GACvB,AAAC,CAAA,EAAE,OAAO,GAAG,+BAAS,UAAU,CAAC,SAAS,AAAD,IAAK,2BAAK,MAAM;IAC3D,OAAO;QACN,+BAAS,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG;QAC3B,+BAAS,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG;IAC5B,CAAC;AACF;AAEA,cAAc;AACd,MAAM,gDAA0B,CAAC,YAAc;IAC9C,+BAAS,MAAM,CAAC,6BAAO;IACvB,+BAAS,MAAM,CAAC,KAAK;IACrB,OAAO,qBAAqB,CAAC;AAC9B;AACA,OAAO,qBAAqB,CAAC","sources":["src/02-sine/index.js","src/02-sine/vert.glsl","src/02-sine/frag.glsl"],"sourcesContent":["import * as THREE from 'three'\n\nimport vertexShader from './vert.glsl'\nimport fragmentShader from './frag.glsl'\n\nconst scene = new THREE.Scene()\nconst loader = new THREE.TextureLoader()\n\nlet theimage = document.getElementById('theimage')\nlet rect = theimage.getBoundingClientRect()\ntheimage.remove()\n\nconst renderer = new THREE.WebGLRenderer({})\nrenderer.setPixelRatio(window.devicePixelRatio)\nrenderer.setSize(rect.width, rect.height)\ndocument.body.appendChild(renderer.domElement)\n\nlet camera = new THREE.OrthographicCamera(\n\trect.width / -2,\n\trect.width / 2,\n\trect.height / 2,\n\trect.height / -2\n)\ncamera.position.set(0, 0, 1)\n\nlet uniforms = {\n\tu_time: { value: 0 },\n\tu_res: { value: new THREE.Vector2(rect.width, rect.height) },\n\tu_mouse: { type: 'v2', value: new THREE.Vector2() },\n}\n\nlet image = loader.load(theimage.src, () => {\n\tuniforms.u_image = { type: 't', value: image }\n\tlet geometry = new THREE.PlaneBufferGeometry()\n\tlet material = new THREE.ShaderMaterial({\n\t\tuniforms,\n\t\tvertexShader,\n\t\tfragmentShader,\n\t\tdefines: {\n\t\t\tPR: window.devicePixelRatio.toFixed(1),\n\t\t},\n\t})\n\tlet mesh = new THREE.Mesh(geometry, material)\n\tmesh.scale.set(rect.width, rect.height, 1)\n\tscene.add(mesh)\n})\n\ndocument.onmousemove = function (e) {\n\tif (e.target == renderer.domElement) {\n\t\tuniforms.u_mouse.value.x =\n\t\t\t(e.clientX - renderer.domElement.offsetLeft) / rect.width\n\t\tuniforms.u_mouse.value.y =\n\t\t\t(e.clientY - renderer.domElement.offsetTop) / rect.height\n\t} else {\n\t\tuniforms.u_mouse.value.x = 0\n\t\tuniforms.u_mouse.value.y = 0\n\t}\n}\n\n// render loop\nconst onAnimationFrameHandler = (timeStamp) => {\n\trenderer.render(scene, camera)\n\tuniforms.u_time.value++\n\twindow.requestAnimationFrame(onAnimationFrameHandler)\n}\nwindow.requestAnimationFrame(onAnimationFrameHandler)\n","varying vec2 v_uv;\nuniform vec2 u_mouse;\n\nvoid main() {\n    v_uv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}","\nuniform vec2 u_res;\nuniform sampler2D u_image;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvarying vec2 v_uv;\n\nvoid main() {\n\n    vec2 uv = v_uv;\n\n    // vec2 res = u_res * PR;\n    // vec2 st = gl_FragCoord.xy / res.xy - vec2(0.5);\n    // st.y *= u_res.y / u_res.x;\n\n    float frequency =  u_mouse.y * 30.0;\n    float amplitude = 0.03 * u_mouse.x;\n    float sineWave = sin(uv.y * frequency + u_time * 0.01) * amplitude;\n\n    // create a vec2 with our sine\n    // what happens if you put sineWave in the y slot? in Both slots?\n    vec2 distort = vec2(sineWave, 0.0);\n\n    vec4 image = texture2D(u_image, uv + distort );\n\n    gl_FragColor = image;\n}"],"names":[],"version":3,"file":"index.3e27b1b3.js.map"}